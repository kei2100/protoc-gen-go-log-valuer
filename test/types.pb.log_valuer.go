// Code generated by protoc-gen-go-log-valuer. DO NOT EDIT.
//
// source: test/types.proto

package test

import (
	fmt "fmt"
	slog "log/slog"
	strconv "strconv"
)

func (x *Types) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 40)
	attrs = append(attrs, slog.String("secret_val", "[REDACTED]"))
	attrs = append(attrs, slog.Float64("double_val", x.DoubleVal))
	_fmt_float_val := strconv.FormatFloat(float64(x.FloatVal), 'f', -1, 32)
	_float_val, _ := strconv.ParseFloat(_fmt_float_val, 64)
	attrs = append(attrs, slog.Float64("float_val", _float_val))
	attrs = append(attrs, slog.Int64("int32_val", int64(x.Int32Val)))
	attrs = append(attrs, slog.Int64("int64_val", x.Int64Val))
	attrs = append(attrs, slog.Uint64("uint32_val", uint64(x.Uint32Val)))
	attrs = append(attrs, slog.Uint64("uint64_val", x.Uint64Val))
	attrs = append(attrs, slog.Int64("sint32_val", int64(x.Sint32Val)))
	attrs = append(attrs, slog.Int64("sint64_val", x.Sint64Val))
	attrs = append(attrs, slog.Uint64("fixed32_val", uint64(x.Fixed32Val)))
	attrs = append(attrs, slog.Uint64("fixed64_val", x.Fixed64Val))
	attrs = append(attrs, slog.Int64("sfixed32_val", int64(x.Sfixed32Val)))
	attrs = append(attrs, slog.Int64("sfixed64_val", x.Sfixed64Val))
	attrs = append(attrs, slog.Bool("bool_val", x.BoolVal))
	attrs = append(attrs, slog.String("string_val", x.StringVal))
	attrs = append(attrs, slog.Any("bytes_val", x.BytesVal))
	attrs = append(attrs, slog.String("enum_val", x.EnumVal.String()))
	if x.OtherTypeVal != nil {
		if v, ok := interface{}(x.OtherTypeVal).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "other_type_val", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("other_type_val", x.OtherTypeVal))
		}
	}
	if x.NestedTypeVal != nil {
		if v, ok := interface{}(x.NestedTypeVal).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "nested_type_val", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("nested_type_val", x.NestedTypeVal))
		}
	}
	if x.OtherTypeNestedTypeVal != nil {
		if v, ok := interface{}(x.OtherTypeNestedTypeVal).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "other_type_nested_type_val", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("other_type_nested_type_val", x.OtherTypeNestedTypeVal))
		}
	}
	if _, ok := x.GetOneofVal().(*Types_OneofStringVal); ok {
		attrs = append(attrs, slog.String("oneof_string_val", x.GetOneofStringVal()))
	}
	if _, ok := x.GetOneofVal().(*Types_OneofInt64Val); ok {
		attrs = append(attrs, slog.Int64("oneof_int64_val", x.GetOneofInt64Val()))
	}
	if _, ok := x.GetOneofVal().(*Types_OneofBoolVal); ok {
		attrs = append(attrs, slog.Bool("oneof_bool_val", x.GetOneofBoolVal()))
	}
	if len(x.MapVal1) == 0 {
		attrs = append(attrs, slog.Any("map_val1", make(map[string]string, 0)))
	} else {
		attrs23 := make([]slog.Attr, 0, len(x.MapVal1))
		for k, v := range x.MapVal1 {
			attrs23 = append(attrs23, slog.String(fmt.Sprintf("%v", k), v))
		}
		attrs = append(attrs, slog.Any("map_val1", attrs23))
	}
	if len(x.MapVal2) == 0 {
		attrs = append(attrs, slog.Any("map_val2", make(map[string]string, 0)))
	} else {
		attrs24 := make([]slog.Attr, 0, len(x.MapVal2))
		for k, v := range x.MapVal2 {
			if vv, ok := interface{}(v).(slog.LogValuer); ok {
				attrs24 = append(attrs24, slog.Attr{Key: fmt.Sprintf("%v", k), Value: vv.LogValue()})
			} else {
				attrs24 = append(attrs24, slog.Any(fmt.Sprintf("%v", k), v))
			}
		}
		attrs = append(attrs, slog.Any("map_val2", attrs24))
	}
	if len(x.MapEmptyVal) == 0 {
		attrs = append(attrs, slog.Any("map_empty_val", make(map[string]string, 0)))
	} else {
		attrs25 := make([]slog.Attr, 0, len(x.MapEmptyVal))
		for k, v := range x.MapEmptyVal {
			attrs25 = append(attrs25, slog.String(fmt.Sprintf("%v", k), v))
		}
		attrs = append(attrs, slog.Any("map_empty_val", attrs25))
	}
	if len(x.RepeatedVal1) == 0 {
		attrs = append(attrs, slog.Any("repeated_val1", make(map[string]string, 0)))
	} else {
		attrs26 := make([]slog.Attr, 0, len(x.RepeatedVal1))
		for i, v := range x.RepeatedVal1 {
			attrs26 = append(attrs26, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("repeated_val1", attrs26))
	}
	if len(x.RepeatedVal2) == 0 {
		attrs = append(attrs, slog.Any("repeated_val2", make(map[string]string, 0)))
	} else {
		attrs27 := make([]slog.Attr, 0, len(x.RepeatedVal2))
		for i, v := range x.RepeatedVal2 {
			attrs27 = append(attrs27, slog.String(fmt.Sprintf("%d", i), v.String()))
		}
		attrs = append(attrs, slog.Any("repeated_val2", attrs27))
	}
	if len(x.RepeatedVal3) == 0 {
		attrs = append(attrs, slog.Any("repeated_val3", make(map[string]string, 0)))
	} else {
		attrs28 := make([]slog.Attr, 0, len(x.RepeatedVal3))
		for i, v := range x.RepeatedVal3 {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs28 = append(attrs28, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs28 = append(attrs28, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("repeated_val3", attrs28))
	}
	if len(x.RepeatedEmptyVal) == 0 {
		attrs = append(attrs, slog.Any("repeated_empty_val", make(map[string]string, 0)))
	} else {
		attrs29 := make([]slog.Attr, 0, len(x.RepeatedEmptyVal))
		for i, v := range x.RepeatedEmptyVal {
			attrs29 = append(attrs29, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("repeated_empty_val", attrs29))
	}
	if x.StructVal != nil {
		if v, ok := interface{}(x.StructVal).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "struct_val", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("struct_val", x.StructVal))
		}
	}
	attrs = append(attrs, slog.String("_String", x.XString))
	if x.OptionalVal != nil {
		attrs = append(attrs, slog.String("optional_val", x.GetOptionalVal()))
	}
	if x.OptionalNotPresentVal != nil {
		attrs = append(attrs, slog.String("optional_not_present_val", x.GetOptionalNotPresentVal()))
	}
	if x.OptionalEnum != nil {
		attrs = append(attrs, slog.String("optional_enum", x.GetOptionalEnum().String()))
	}
	if x.OptionalNotPresentEnum != nil {
		attrs = append(attrs, slog.String("optional_not_present_enum", x.GetOptionalNotPresentEnum().String()))
	}
	if x.OptionalMessage != nil {
		if v, ok := interface{}(x.GetOptionalMessage()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "optional_message", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("optional_message", x.GetOptionalMessage()))
		}
	}
	if x.OptionalNotPresentMessage != nil {
		if v, ok := interface{}(x.GetOptionalNotPresentMessage()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "optional_not_present_message", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("optional_not_present_message", x.GetOptionalNotPresentMessage()))
		}
	}
	if x.PresentMessage != nil {
		if v, ok := interface{}(x.PresentMessage).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "present_message", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("present_message", x.PresentMessage))
		}
	}
	if x.NotPresentMessage != nil {
		if v, ok := interface{}(x.NotPresentMessage).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "not_present_message", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("not_present_message", x.NotPresentMessage))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *Types_NestedType) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.String("nested_string_val", x.NestedStringVal))
	attrs = append(attrs, slog.String("nested_secret_val", "[REDACTED]"))
	return slog.GroupValue(attrs...)
}

func (x *OtherType1) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.String("other_string_val", x.OtherStringVal))
	attrs = append(attrs, slog.String("other_secret_val", "[REDACTED]"))
	return slog.GroupValue(attrs...)
}

func (x *OtherType2) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *OtherType2_NestedType) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.String("nested_string_val", x.NestedStringVal))
	attrs = append(attrs, slog.String("nested_secret_val", "[REDACTED]"))
	return slog.GroupValue(attrs...)
}

func (x *OtherType3) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("val", x.Val))
	return slog.GroupValue(attrs...)
}
